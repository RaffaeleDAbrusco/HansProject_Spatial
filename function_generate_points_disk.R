## Collection of functions that produce random distribution of 
## simulated sky coordinates according to a specified disk
## geometry and orientation.
##
## Written by R. D'Abrusco
##
## Last modified: 23/6/16.

suppressMessages(require(plotrix))			# Required to plot ellipse.

point_in_disk <- function(a, ellipticity, theta, ra, dec, ra_gal, dec_gal) {
	# This function calculates the value of the oval equation 
	# with given a (measured along the major axis), ellipticity,
	# position angle and center for points whose sky coordinates are x and y
	# Arguments:
	#	a			->	semimajor axis of the ellipse
	#	ellipticity	->	ellipticity of the ellipse
	#	theta		->	position angle of the ellipse
	#	ra			->	right ascension of the points to be tested
	#	dec			->	declination of the points to be tested
	#	ra_gal		->	right ascension of the center of the galaxy
	#	dec_gal		->	declination of the center of the galaxy
	
	# Converting measure of the angle in degrees to radians	
	theta = pi*theta/180
	
	# Calculating the semi-minor axis given the ellipticity and 
	# the semi-major axis.	
	b = a*(1 - ellipticity)

	# Evaluating the point locus, and returning it
	locus = ((ra - ra_gal)^2*cos(theta)^2 + (dec - dec_gal)^2*sin(theta)^2 + 2*(ra - ra_gal)*(dec - dec_gal)*sin(theta)*cos(theta))/a^2 + 
			((ra - ra_gal)^2*sin(theta)^2 + (dec - dec_gal)^2*cos(theta)^2 - 2*(ra - ra_gal)*(dec - dec_gal)*sin(theta)*cos(theta))/b^2	
	return(locus)
	}

points_in_ellipses <- function(radial_bins, 
							   ellipticity, 
							   theta, 
							   ra_obs, dec_obs, 
							   ra_gal, dec_gal) {
	# This function returns indices and numbers of observed positions in the sky
	# within elliptical annuli generated by a given sequence of semi-major axix values
	# and fixed ellipticity, position angle and center.
	# Arguments:
	#	radial_bins	->	sequence of semimajor axes defining the elliptical annuli
	#	ellipticity	->	ellipticity of the elliptical annuli
	#	theta		->	position angle of the ellipse
	#	ra_obs		->	observed values of the right ascension
	#	dec_obs		->	observed values of the declination 
	#	ra_gal		->	right ascension of the center of the galaxy
	#	dec_gal		->	declination of the center of the galaxy
	
	## Determining which sources fall within the elliptical annuli.
	idx_points_radial_bins = list()
	radeg_points_radial_bins = list()
	numsources_radial_bins = vector(mode = "numeric", length = length(radial_bins) - 1)
	# First (inner) ellipse
	idx_points_radial_bins[[1]] = which(point_in_ellipse(radial_bins[2], ellipticity, theta, 
									   					 ra_obs, dec_obs, 
									   					 ra_gal, dec_gal) <= 1)
	numsources_radial_bins[1] = length(idx_points_radial_bins[[1]])
	# Elliptical annuli.
	for (idx_radial_bin in seq(2, length(radial_bins) - 1)) {
		idx_points_radial_bins[[idx_radial_bin]] = which(point_in_ellipse(radial_bins[idx_radial_bin], ellipticity, theta, 
														 				  ra_obs, dec_obs, 
														 				  ra_gal, dec_gal) > 1 &
												 	     point_in_ellipse(radial_bins[idx_radial_bin + 1], ellipticity, theta, 
												 	     				  ra_obs, dec_obs, 
												 	     				  ra_gal, dec_gal) <= 1)
		numsources_radial_bins[idx_radial_bin] = length(idx_points_radial_bins[[idx_radial_bin]])
		radeg_points_radial_bins[[idx_radial_bin]] = cbind(ra_obs[idx_points_radial_bins[[idx_radial_bin]]], 
														   dec_obs[idx_points_radial_bins[[idx_radial_bin]]])
		}
	
	# Returning the structure containing the numbers and indices
	# of observed positions in elliptical annuli	
	structure_points_in_ellipses = list(x = idx_points_radial_bins, y = numsources_radial_bins, z = radeg_points_radial_bins)
	return(structure_points_in_ellipses)	
	}

generate_points_ellipse <- function(radial_bins, 
									ellipt, theta, 
									numpoints_all, 
									numpoints_radial_bins, 
									ra_gal, dec_gal, 
									ra_range, dec_range, 
									factor) {
	# This function generates the sky coordinates of points randomly distributed
	# according to an elliptical geometry with given ellipticity, semi-major axes
	# values, position angle and center.
	# Arguments:
	#	radial_bins 		->	vector of increasing semi-major axes values
	#	ellipt				->	fixed ellipticity of the ellipses
	#	theta				->	fixed position angle of the ellipses
	#	numpoints			->	total number of points to be simulated
	#	numpoints_radial_bins	->	vector whose elements are the numbers of simulated points
	#								per elliptical annulus
	#	ra_gal		->	right ascension of the center of the galaxy
	#	dec_gal		->	declination of the center of the galaxy	
	# 	ra_range	->	range over which right ascension values have to be generated
	#	dec_range	->	range over which declination values have to be generated
	#	factor		->	integer factor to be used to create a larger distribution whence
	#					random simulated numbers position in elliptical annuli are drawn
	
	# Generating the random x and y coordinates within the 
	# intervals specified by ra_range and dec_range
	sim_xy_all = array(0, dim = c(numpoints_all*factor, 2))
	sim_xy_all[, 1] = runif(numpoints_all*factor, min = min(ra_range), max = max(ra_range))
	sim_xy_all[, 2] = runif(numpoints_all*factor, min = min(dec_range), max = max(dec_range))
			  			   
	# Picking the randomly generated points in each elliptical
	# annulus centered on the given center of the galaxy
	idx_points_radial_bin = list()
	points_radial_bin = list()
	idx_points_radial_bin[[1]] = which(point_in_ellipse(radial_bins[2], ellipt, theta, sim_xy_all[, 1], sim_xy_all[, 2], ra_gal, dec_gal) <= 1)
	points_radial_bin[[1]] = sim_xy_all[idx_points_radial_bin[[1]][sample(length(idx_points_radial_bin[[1]]), numpoints_radial_bins[1])], ]
	for (idx_radial_bin in seq(2, length(radial_bins) - 1)) {
		idx_points_radial_bin[[idx_radial_bin]] = which(point_in_ellipse(radial_bins[idx_radial_bin], ellipt, theta, sim_xy_all[, 1], sim_xy_all[, 2], ra_gal, dec_gal) > 1 &
												 	    point_in_ellipse(radial_bins[idx_radial_bin + 1], ellipt, theta, sim_xy_all[, 1], sim_xy_all[, 2], ra_gal, dec_gal) <= 1)
		points_radial_bin[[idx_radial_bin]] = 
			sim_xy_all[idx_points_radial_bin[[idx_radial_bin]][sample(length(idx_points_radial_bin[[idx_radial_bin]]), numpoints_radial_bins[idx_radial_bin])], ]
		}

	# Returning the structure containing the output.	
	output_generate_points_ellipse = list(x = sim_xy_all, y = points_radial_bin)	
	return(output_generate_points_ellipse)
	}

if (1 == 0) {
pippo_radial_bins = seq(0, 0.5, length.out = 20)
pippo_ellipticity = 0.33
pippo_theta = 248
pippo_numtotal_points = 1000
pippo_ra_gal = 151.308250 
pippo_dec_gal = -7.718583
pippo_range_ra = c(151 - 0.2, 151.6 + 0.2)	# Range along the R.A. for plots. 
pippo_range_dec = c(-8.1 - 0.2, -7.5 + 0.2)	# Range along the Dec. for plots.
pippo_numpoints_radial_bins = rep(1000/20, length(pippo_radial_bins))
pippo_random_points_ra = runif(10000, min = min(pippo_range_ra), max = max(pippo_range_ra))
pippo_random_points_dec = runif(10000, min = min(pippo_range_dec), max = max(pippo_range_dec))
pippo_cazzo = points_in_ellipses(pippo_radial_bins, pippo_ellipticity, 
								 pippo_theta, 
								 pippo_random_points_ra, pippo_random_points_dec, 
								 pippo_ra_gal, pippo_dec_gal)
pippo_cazzo_indices = pippo_cazzo$x 
pippo_cazzo_number = pippo_cazzo$y	
#browser()												  
#pippo_in_ellipse1 = point_in_ellipse(0.27777778, pippo_ellipticity, pippo_theta, pippo_random_points_x, pippo_random_points_y, pippo_ra_gal, pippo_dec_gal)
#pippo_in_ellipse2 = point_in_ellipse(0.2, pippo_ellipticity, pippo_theta, pippo_random_points_x, pippo_random_points_y, pippo_ra_gal, pippo_dec_gal)
#pippo_in_ellipse3 = point_in_ellipse(0.14, pippo_ellipticity, pippo_theta, pippo_random_points_x, pippo_random_points_y, pippo_ra_gal, pippo_dec_gal)
#pippo_in_ellipse4 = point_in_ellipse(0.09, pippo_ellipticity, pippo_theta, pippo_random_points_x, pippo_random_points_y, pippo_ra_gal, pippo_dec_gal)
#idx_pippo_in_ellipse1 = which(pippo_in_ellipse1 <= 1)
#idx_pippo_in_ellipse2 = which(pippo_in_ellipse2 <= 1)
#idx_pippo_in_ellipse3 = which(pippo_in_ellipse3 <= 1)
#idx_pippo_in_ellipse4 = which(pippo_in_ellipse4 <= 1)
#pippo_color_in_ellipse1 = rep("red", 1000)
#pippo_color_in_ellipse2 = rep("darkgreen", 1000)
#pippo_color_in_ellipse3 = rep("cyan", 1000)
#pippo_color_in_ellipse4 = rep("darkblue", 1000)
#pippo_color_in_ellipse1[which(pippo_in_ellipse1 > 1)] = "NA"
#pippo_color_in_ellipse2[which(pippo_in_ellipse2 > 1)] = "NA"
#pippo_color_in_ellipse3[which(pippo_in_ellipse3 > 1)] = "NA"
#pippo_color_in_ellipse4[which(pippo_in_ellipse4 > 1)] = "NA"
pippo = generate_points_ellipse(pippo_radial_bins, pippo_ellipticity, pippo_theta, 
								pippo_numtotal_points, pippo_numpoints_radial_bins,
								pippo_ra_gal, pippo_dec_gal, 
								pippo_range_ra, pippo_range_dec, 100)
pippo_allrandom = pippo$x 
pippo_ellipse = pippo$y								
#browser()
quartz()
plot(seq(-10, 10), seq(-10, 10), 
	 xlim = rev(pippo_range_ra), ylim = pippo_range_dec, 
	 xlab = "R.A.", ylab = "Dec", type = "n")	
#points(pippo_random_points_x, pippo_random_points_y, col = pippo_color_in_ellipse1, cex = 1, pch = 20)
#points(pippo_random_points_x, pippo_random_points_y, col = pippo_color_in_ellipse2, cex = 1, pch = 20)
#points(pippo_random_points_x, pippo_random_points_y, col = pippo_color_in_ellipse3, cex = 1, pch = 20)
#points(pippo_random_points_x, pippo_random_points_y, col = pippo_color_in_ellipse4, cex = 1, pch = 20)
#points(pippo_random_points_x[idx_pippo_in_ellipse1], pippo_random_points_y[idx_pippo_in_ellipse1], col = "red", cex = 1, pch = 20)
#points(pippo_random_points_x[idx_pippo_in_ellipse2], pippo_random_points_y[idx_pippo_in_ellipse2], col = "darkgreen", cex = 1, pch = 20)
#points(pippo_random_points_x[idx_pippo_in_ellipse3], pippo_random_points_y[idx_pippo_in_ellipse3], col = "cyan", cex = 1, pch = 20)
#points(pippo_random_points_x[idx_pippo_in_ellipse4], pippo_random_points_y[idx_pippo_in_ellipse4], col = "darkblue", cex = 1, pch = 20)
#points(pippo_allrandom[, 1], pippo_allrandom[, 2], col = "gray", pch = 20, cex = 0.1)
for (idx_cazzo in seq(length(pippo_cazzo_indices))) {
	points(pippo_random_points_ra[pippo_cazzo_indices[[idx_cazzo]]], 
		   pippo_random_points_dec[pippo_cazzo_indices[[idx_cazzo]]], 
	   	   col = sample(colours(), 1), pch = 20, cex = 1)
	}
for (idx in seq(length(pippo_ellipse))) {
	pippo_color = sample(colours(), 1)
	draw.ellipse(pippo_ra_gal, pippo_dec_gal, 
				 a = pippo_radial_bins[idx + 1], 
			 	 b = pippo_radial_bins[idx + 1]*(1 - pippo_ellipticity), 
			 	 angle = pippo_theta,
			 	 nv = 1000, 
			 	 border = pippo_color,
			 	 col = "NA",
			 	 lwd = 2, 
			 	 deg = TRUE)	
	points(pippo_ellipse[[idx]][, 1], pippo_ellipse[[idx]][, 2], 
	   	   pch = 20, 
	   	   cex = 1, 
	       col = pippo_color)
	}
}	